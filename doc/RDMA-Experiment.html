<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="markdown.css" type="text/css" />
</head>
<body>
<h1 id="מעבדה-בתקשורת-rdma">מעבדה בתקשורת RDMA</h1>
<p>על מנת לאפשר לשרתים לעבוד בקצבי תקשורת הולכים וגדלים, כרטיסי תקשורת מודרניים מאפשרים מעקף של ליבת מערכת ההפעלה וממשק ישיר בין תהליכי משתמש ובין החומרה. בנוסף חלק ממשימות התקשורת מואצות על גבי כרטיס הרשת כדי להפחית מהעומס על המעבד הראשי. בניסוי נלמד כיצד פועלים מנגנונים אלה, ונמדוד את השפעתם על הביצועים של יישומי תקשורת. על מנת ללמוד כיצד לפתח יישומי RDMA בשפת C, נבנה במהלך הניסוי מערכת המשתפת את זיכרון השרת באמצעות RDMA ללקוחות קצה.</p>
<h2 id="מיקום">מיקום</h2>
<p>הניסוי מתבצע ב<strong>חדר 375</strong> במסדרון בין פישבך למאייר.</p>
<h2 id="תוכן-עניינים">תוכן עניינים</h2>
<ol style="list-style-type: decimal">
<li><a href="#רקע">חומר רקע</a></li>
<li><a href="#חלק-א">חלק ראשון - מדידות ביצועים</a></li>
<li><a href="#חלק-ב">חלק שני - תכנות RDMA</a></li>
</ol>
<h1 id="רקע">רקע <a name="רקע"/></h1>
<h2 id="מעקף-ליבת-מערכת-ההפעלה">מעקף ליבת מערכת ההפעלה</h2>
<p>מערכות הפעלה על פי רוב לוקחות על עצמן את מימוש פרוטוקולי התקשורת של שכבות הרשת (IP) וה-Transport ‏(TCP), ומציגות בפני תוכניות משתמש ממשק מופשט של תקשורת (sockets). מערכת ההפעלה היא היחידה בעלת הגישה לכרטיס הרשת, ולכן תפקיד נוסף שלה היא לסווג את החבילות המתקבלות ולשייך אותן לתוכנית המשתמש המתאימה.</p>
<p>גישה זו משחררת את המתכנת מעול המימוש של הפרוטוקולים השונים, ומהיכרות עם פרטי כרטיס הרשת המסוים המותקן במחשב. אולם, לגישה זו מספר חסרונות: שליחה וקבלה של מידע כוללת החלפות הקשר של המעבד, מן ההקשר של תהליך המשתמש, אל מערכת ההפעלה, ובחזרה. החלפת הקשר מעכבת את ביצוע תוכנית המשתמש, ובמהלכה אובד חלק ממצב המעבד, מה שפוגע בביצועי המערכת.</p>
<p>מכיוון שמערכת ההפעלה היא היחידה המתקשרת עם כרטיס הרשת, מידע שנשלח מתוכנית המשתמש ראשית מועתק לזיכרון של ליבת מערכת ההפעלה (kernel), ורק לאחר מכן נשלח לרשת. בדומה לכך מידע שמתקבל מן הרשת מושם בזיכרון של הליבה, ורק לאחר שמערכת ההפעלה מסווגת אותו הוא מועתק לזיכרון תהליך המשתמש. ההעתקה של המידע מעכבת את קבלתו ושליחתו, ומשתמשת במעבד שהיה יכול לבצע חישובים מועילים יותר באותו הזמן.</p>
<p>כרטיסי תקשורת חדשים יותר מסוגלים לעבוד עם תוכניות משתמש באופן ישיר, ללא מעורבות של מערכת ההפעלה. באמצעות מערכת מיפוי זיכרון מקבילה ל- memory management unit (MMU) של המעבד הראשי. כשם שהמעבד הראשי מתרגם כתובות זכרון וירטואליות ממרחב הזכרון של התהליך הנוכחי למרחב הזכרון הפיזי, כך כרטיס הרשת גם הוא משתמש בזיכרון וירטואלי ומסוגל להפריד בין תהליכים שונים. עקב כך תוכנית המשתמש יכולה לתת הוראות קבלה או שליחה עם כתובות במרחב הווירטואלי שלה, ישירות לכרטיס. הכרטיס מוודא שהכתובות חוקיות, ומבצע את ההוראות. מערכת ההפעלה מעורבת רק בזמן יצירת התקשורת הישירה בין תוכנית המשתמש לכרטיס הרשת.</p>
<p>בניסוי נראה כיצד שימוש בספריית VMA המממשת פרוטוקולי תקשורת בסביבת המשתמש משפרת ביצועים לתוכניות רשת. הספרייה מממשת פרוטוקולי TCP/IP באמצעות גישה ישירה לכרטיס הרשת, ומחליפה באופן שקוף את ממשקי המשתמש של מערכת ההפעלה.</p>
<h3 id="פסיקות-interrupts-לעומת-דגימה-polling">פסיקות (interrupts) לעומת דגימה (polling)</h3>
<p>כאשר תהליך ממתין לביצוע פעולת קלט/פלט, כמו קבלת מידע מהרשת או שליחת מידע, מערכת ההפעלה משהה את ריצת התהליך, ומאפשרת לתהליכים אחרים לנצל את המעבד. כרטיס הרשת מודיע למערכת ההפעלה על אירועי קלט/פלט באמצעות פסיקה, אשר גורמת למעבד להפסיק את ריצת התהליך הנוכחי, לעבד את החבילות שהתקבלו, ולסמן את התהליך שממתין לתקשורת כ&quot;מוכן לריצה&quot;. לאחר מכן, לפי החלטת סדרן התוכניות (Scheduler), מתבצעת החלפת הקשר והתהליך המקורי ממשיך את הריצה שלו.</p>
<p>מנגנון פסיקות זה מאפשר ניצול יעיל של המעבד, על ידי השהיית תהליכים הממתינים לקלט/פלט, וניצול המעבד בזמן ההמתנה לחישובים אחרים. עם זאת, למנגנון זה יש תקורה: הזמן שלוקח מרגע קבלת חבילה ועד הגעת המידע לתהליך המשתמש גדול יחסית. דרך אחרת לקבל מידע שמשתלבת עם מעקף מערכת ההפעלה היא להשתמש בדגימה (polling) חוזרת ונשנית של מצב פעולת קלט/פלט. התהליך מבקש את ביצוע הפעולה ואז אינו מוותר על זכות השימוש במעבד אלא ממשיך לדגום שוב ושוב האם הפעולה הסתיימה. באופן זה מתקצרת ההשהייה של קבלת הודעות, אולם המעבד מנוצל ב-100% לטובת תהליך הקלט/פלט וביצוע הדגימות.</p>
<p>ספריית VMA בה נשתמש בניסוי מפעילה מנגנון דגימה שכזה כברירת מחדל.</p>
<h2 id="האצת-פרוטוקולי-רשת">האצת פרוטוקולי רשת</h2>
<p>לעתים עקיפת מערכת ההפעלה אינה מספיקה כדי לתת את הביצועים הנדרשים. כדי להפחית עוד יותר מהעומס על המעבד הראשי בפעולות תקשורת, מעבירים חלק ממימוש שכבות הרשת וה-Transport לכרטיס הרשת. חומרת כרטיס הרשת מסוגלת לבצע את העיבוד הנדרש במקביל למעבד הראשי, וכך הוא מתפנה לבצע משימות אחרות. בניסוי זה אנחנו מתמקדים בפרוטוקולים ממשפחת RoCE – RDMA over Converged Ethernet, תוך שימוש במעקף ליבת מערכת ההפעלה בנוסף להאצת פרוטוקול הרשת.</p>
<p>כאשר שולחים או מקבלים הודעות, פרוטוקול reliable connected (RC) ממשפחת RoCE מאפשר לתוכנית המשתמש לספק הודעות גדולות לשליחה (עד 2GB), או חוצצים גדולים לקבלת הודעות, ולהסתמך על כרטיס הרשת לנהל את הפרוטוקול בחומרה. כרטיס הרשת מטפל בחלוקת ההודעה לחבילות, שליחת אישורי קבלה, סידור ההודעות המתקבלות ושליחה חוזרת במקרים של אובדן חבילות. כך מתפנה המעבד הראשי לביצוע חישובים של תוכנית המשתמש.</p>
<p>טכנולוגית RDMA (Remote Direct Memory Access) מאפשרת גם גישה ישירה לזיכרון מרוחק. אנחנו מתייחסים לתחנות הקצה בתור היוזם והיעד. היוזם מבקש לשלוח מידע אל היעד, או למשוך ממנו מידע. היעד מקבל את הבקשה ומאחסן את המידע שהתקבל (אם מדובר בשליחה), או שולח את התשובה (אם מדובר בבקשה לקריאה). מבחינים בין תקשורת דו-צדדית ותקשורת חד-צדדית, לפי מידת המעורבות של המעבד הראשי בצד היעד. בתקשורת דו-צדדית הצד היוזם שולח הודעה אל היעד, והיעד מספק חוצץ זכרון לקבלת ההודעה ומקבל התראה על קבלתה. לעומת זאת, בתקשורת חד-צדדית, הצד היוזם מסוגל לגשת לזכרון מרוחק באופן ישיר. הצד היוזם שולח הוראה לבצע כתיבה או קריאה של זיכרון השייך ליעד, וכרטיס הרשת של היעד מבצע את ההוראה מבלי לערב את המעבד הראשי.</p>
<p>בניסוי נבחן את ההשפעה של שימוש בהאצת חומרה של פרוטוקול הרשת על הביצועים, ונכתוב תכנית שרת-לקוח פשוטה המשתמשת ב-RDMA על מנת לשתף זיכרון מרוחק.</p>
<h2 id="חומר-רקע-נוסף">חומר רקע נוסף</h2>
<p>חומר רקע לגבי טכנולוגית RDMA ומעקף ליבת מערכת ההפעלה ניתן למצוא בשקפים המצורפים מתוך קורס RDMA באוניברסיטה העברית.</p>
<p>מידע נוסף על כלי המדידה אשר בשימוש בניסוי ניתן למצוא במקורות הבאים:</p>
<ul>
<li><p>המדריך למשתמש של sockperf:‏ <a href="https://www.mankier.com/3/sockperf">sockperf man page</a></p></li>
<li><p>כלי cpufrequtils לשליטה בתדר השעון של המעבד: <a href="https://manpages.debian.org/stretch/cpufrequtils/cpufreq-set.1.en.html">man cpufreq-set</a></p></li>
<li><p><a href="https://community.mellanox.com/docs/DOC-2802">תיעוד של חבילת perftest</a> הכוללת כלי מדידת ביצועים לתקשורת RDMA</p></li>
</ul>
<p>ניתן לקרוא על ממשקי התכנות לשימוש ב-RDMA ב<a href="https://www.mellanox.com/related-docs/prod_software/RDMA_Aware_Programming_user_manual.pdf">מדריך לתכנות רשתות RDMA</a> (אנגלית) של מלאנוקס. החלקים הרלוונטיים הינם:</p>
<ul>
<li><p>פרק 2 RDMA-Aware Programming Overview, עמודים 19-24.</p></li>
<li><p>פרק 4 RDMA_CM API. הפונקציות הרלוונטיות למעבדה הן:</p>
<ul>
<li><p><code>rdma_create_id</code></p></li>
<li><p><code>rdma_create_ep</code></p></li>
<li><p><code>rdma_listen</code></p></li>
<li><p><code>rdma_connect</code></p></li>
<li><p><code>rdma_get_request</code></p></li>
</ul></li>
<li><p>פרק 5 RDMA Verbs API. הפונקציות הרלוונטיות הן:</p>
<ul>
<li><p><code>rdma_reg_msgs</code></p></li>
<li><p><code>rdma_reg_read</code></p></li>
<li><p><code>rdma_reg_write</code></p></li>
<li><p><code>rdma_post_recv</code></p></li>
<li><p><code>rdma_post_send</code></p></li>
<li><p><code>rdma_post_read</code></p></li>
<li><p><code>rdma_post_write</code></p></li>
<li><p><code>rdma_get_send_completion</code></p></li>
<li><p><code>rdma_get_recv_completion</code></p></li>
</ul></li>
</ul>
<h1 id="חלק-ראשון---מדידות-ביצועים"><a name="חלק-א"/> חלק ראשון - מדידות ביצועים</h1>
<h2 id="תרגיל-1-התמצאות">תרגיל 1: התמצאות</h2>
<p>בתרגיל זה נכיר את תכונות המערכת שעליה נבצע את הניסוי.</p>
<p>על מנת להשתמש במחשבי הניסוי השתמשו במשתמש rdmauser. כדי להשתמש בשורת הפקודה פתחו את ישום המסוף.</p>
<p>במחשב מספר כרטיסי רשת. ניתן לזהות אותם באמצעות הפקודה ip link show. רק שניים מהם תומכים ב-RDMA ובאחד מהם נשתמש בניסוי. מצאו מהם באמצעות הפקודה:</p>
<pre><code>ls /sys/class/infiniband_verbs/uverbs0/device/net/</code></pre>
<p>אלו שני פורטים של כרטיס רשת יחד התומך ב-RDMA. רק אחד מהם מחובר לשרת השני. מצאו את הפורט המחובר באמצעות הסתכלות בפלט של <code>ip link show</code> – הפורט המנותק יופיע עם הדגל <code>NO-CARRIER</code>.</p>
<p>במכונות של הניסוי יופיע הכרטיס כ-eth2.</p>
<p>נסמן את כרטיס הרשת כ-‎<code>$dev</code>. מצאו את כתובת ה-IP של כרטיס זה באמצעות הפקודה <code>ip addr show $dev</code>. נסמן את כתובת ה-IP של השרת ‎<code>$server_ip</code> הלקוח ‎<code>$client_ip</code>.</p>
<p>תוכלו להגדיר את שם הכרטיס וכתובות ה-ip כמשתני סביבה כדי להקל על הקלדתם. לדוגמה:</p>
<pre><code>dev=eth2
server_ip=192.168.0.101
client_ip=192.168.0.102</code></pre>
<h4 id="שאלה-1.1">שאלה 1.1</h4>
<p>בדקו את מהירות כרטיס הרשת שמצאתם באמצעות הפקודה:</p>
<pre><code>ethtool $dev</code></pre>
<p>מהי מהירות הכרטיס?</p>
<h3 id="ריבוי-ליבות-multi-core-processing">ריבוי ליבות (Multi-core Processing)</h3>
<h4 id="שאלה-1.2"><a name="lstopo"> שאלה 1.2</h4>
<p>הציגו את מבנה המחשב עליו אתם עובדים באמצעות הפקודה <code>lstopo</code>. כמה מעבדים יש במכונה? כמה ליבות יש במכונה? כמה חוטים? האם הזכרון מחובר בחיבור אחיד או בארכיטקטורת NUMA (Non-uniform memory architecture)‎?</p>
<p>מערכת ההפעלה לינוקס מנסה לאזן את העומס על ליבות המעבד השונות (CPU cores), ולעתים זה מחליפה את הליבה שעליה רץ תהליך מסוים. כדי למנוע החלפות שכאלה במהלך כל ניסוי, נעדיף לקבוע עבור מערכת ההפעלה שיש להשתמש בליבה מסוימת בכל ניסוי. לשם כך נשתמש בכלי <code>taskset</code>. הכלי מקבל פרמטר ‎-c ולאחריו את מספר הליבה שעליה יש להריץ את התוכנית המבוקשת. כך למשל על מנת להריץ את <code>ib_send_bw</code> על ליבה מספר 3, נפעיל את הפקודה:</p>
<pre><code>taskset -c 3 ib_send_bw …</code></pre>
<p>שימו לב: יש להוסיף את הפקודה <code>taskset</code> לפני כל פקודה שצריכה להעשות על ליבה מסוימת.</p>
<h3 id="חיבור-מרוחק">חיבור מרוחק</h3>
<p>במהלך הניסוי תעבדו על שתי המכונות במקביל. כדי להקל על העבודה, התחברו מן אחת המכונות אל השניה בחיבור מרוחק ssh המאפשר שימוש בשורת הפקודה של המכונה המרוחקת:</p>
<pre><code>ssh &lt;hostname / ip address&gt;</code></pre>
<p>מומלץ לפתוח שני חלונות מסוף: אחד עבור המכונה המקומית, ואחד עבור המכונה המרוחקת.</p>
<h2 id="תרגיל-2-tcp-ומעקף-ליבת-מערכת-ההפעלה-kernel-bypass">תרגיל 2: TCP ומעקף ליבת מערכת ההפעלה (Kernel Bypass)</h2>
<p>בחלק זה של הניסוי נשתמש בכדי למדידת ביצועים של פרוטוקול TCP בשם sockperf. בצד השרת הפקודה המתאימה היא:</p>
<pre><code>sockperf server --tcp</code></pre>
<p>בצד הלקוח הפעילו את sockperf למדידת קצב העברת הנתונים באמצעות בדיקת throughput של sockperf. במצב זה התוכנית מנסה לשלוח את המספר המירבי של בתים לצד השני עד לגודל חלון ה-TCP. הפעילו את הפקודה:</p>
<pre><code>sockperf throughput --tcp -i $server_ip --msg-size 1472 -t 10</code></pre>
<p>אנו משתמשים בגודל הודעה מקסימלי (1472) על מנת לקבל קצב העברה גבוה יותר ולהפחית היחס בין כמות העבודה הנדרשת מן המעבד למספר הבתים המועברים. ניתן לשלוט במשך זמן הניסוי באמצעות הפרמטר ‎<code>-t</code>.</p>
<p>במהלך הריצה, מדדו גם את ניצולת המעבד באמצעות הכלי <code>top</code> או הכלי הגרפי System Monitor. בכלי <code>top</code> תוכלו להציג את ניצול כל ליבת מעבד (core) בנפרד באמצעות לחיצה על המקש <kbd>1</kbd>. הכלי מציג (בשורה השלישית של הפלט) בנפרד את העומס בשל תוכניות משתמש (<code>us</code>) ותוכניות משתמש בעדיפות נמוכה (<code>ni</code>), ליבת מערכת ההפעלה (<code>sy</code>), המתנה לקלט/פלט (<code>wa</code>). אחוז הזמן של המעבד בו הוא ממתין ללא פעילות מופיע תחת <code>id</code>.</p>
<h3 id="השהיית-רשת">השהיית רשת</h3>
<p>למדידת השהיית הרשת, נפעיל את <code>sockperf</code> במצב <code>ping-pong</code> בו כל הודעה נשלחת רק לאחר קבלת ההודעה הקודמת (החליפו את הפרמטר <code>throughput</code> ב-<code>ping-pong</code>). כך מדידת זמן ההעברה הכולל מאפשר למדוד את השהיית הרשת בין שתי התחנות. השתמשו בפרוטוקול UDP המתאים יותר למדידת השהייה על ידי השמטת הפרמטר ‎<code>--tcp</code> משורת הפקודה של <code>sockperf</code> (בצד השרת ובצד הלקוח), ובחרו גודל הודעה קטן (16 בתים) כדי למזער את השפעת זמן השידור על השהיית הרשת.</p>
<h3 id="מעקף-ליבת-מערכת-ההפעלה-1">מעקף ליבת מערכת ההפעלה</h3>
<p>עד עתה השתמשנו במימוש של פרוטוקול TCP בתוך ליבת מערכת ההפעלה. כעת נחליף אותו על ידי שימוש בספריית VMA במימוש העוקף את ממשקי מערכת ההפעלה ומתקשר ישירות עם כרטיס הרשת. כדי לגרום לתוכנית להשתמש ב-VMA נגדיר זמנית את משתנה הסביבה <code>LD_PRELOAD=libvma.so</code>. כדי לקבל הרשאה לגישה ישירה לכרטיס הרשת, עלינו לקבל הרשאה של משתמש-על באמצעות הפקודה sudo. לסיכום על מנת להפעיל את sockperf נשתמש בפקודה:</p>
<pre><code>sudo env LD_PRELOAD=libvma.so sockperf …</code></pre>
<p>השתמשו ב-VMA בצד השרת ובצד הלקוח. מדדו קצב ההעברה ואת השהיית הרשת תוך שימוש בספריית VMA, עבור אותם גדלי הודעות מן הניסוי הקודם (16 בתים להשהיית הרשת ו-1472 בתים לקצב ההעברה). מדדו גם את ניצולת המעבד. השוו את התוצאות והסבירו את התוצאות שקיבלתם.</p>
<p>הערה: VMA עשוי להדפיס אזהרה על כך שאין דפים גדולים huge pages זמינים במכונה. ניתן להתעלם מאזהרה זו.</p>
<h2 id="תרגיל-3-שימוש-בפרוטוקול-roce">תרגיל 3: שימוש בפרוטוקול RoCE</h2>
<p>כעת נבחן את השימוש בפרוטוקול תקשורת מואץ בחומרה, כתחליף ל-TCP. נשתמש באוסף ישומי perftest למדידת ביצועי RoCE.</p>
<p>למדידת קצב העברה נשתמש בכלי <code>ib_send_bw</code>. על השרת, נפעיל את הכלי ללא פרמטרים נוספים:</p>
<pre><code>ib_send_bw</code></pre>
<p>בצד הלקוח (השולח), נפעיל את הכלי עם כתובת השרת כפרמטר:</p>
<pre><code>ib_send_bw $server_ip</code></pre>
<p>ניתן לשלוט במשך הניסוי באמצעות הפרמטר ‎<code>-D</code>. יש להעביר את אותו משך הזמן גם לשרת וגם ללקוח אחרת יתקבלו תוצאות שגויות.</p>
<p>כעת הריצו את אותו הניסוי אבל תוך שימוש בגודל הודעה קטן (השתמשו בפרמטר ‎<code>-s</code>) של 16 בתים (העבירו את הפרמטר גם לשרת וגם ללקוח). מהו קצב ההעברה (מספר הודעות לשניה) שהתקבל, ומדוע?</p>
<p>כדי למדוד את השהיית הרשת, נשתמש בכלי <code>ib_send_lat</code>, הפועל באופן דומה.</p>
<p>מדדו את קצב ההעברה והשהיית הרשת, והשוו את התוצאות לתוצאות שהתקבלו בשימוש ב-VMA. מה מקור ההבדל?</p>
<h3 id="גישה-לזכרון-מרוחק">גישה לזכרון מרוחק</h3>
<p>פרוטוקול RoCE מאפשר גם גישה לזכרון מרוחק ללא מעורבות של המעבד שאליו שייך הזכרון. נדגים זאת באמצעות תוכנית הבדיקה <code>ib_write_bw</code>, בה תוכנית הלקוח מבצעת כתיבות לזכרון של תוכנית השרת. אופן הפעולה שלה זהה לשאר תוכניות perftest.</p>
<p>מדדו את קצב העברת הנתונים באמצעות <code>ib_write_bw</code> תוך שימוש בהודעות גדולות (גודל ברירת המחדל). מדדו במהלך הריצה את ניצול המעבד בצד השרת ובצד הלקוח. הסבירו את ההבדלים בין הצדדים.</p>
<h3 id="האטת-קצב-המעבד">האטת קצב המעבד</h3>
<p>דרך אחרת לבחון את ניצולת המעבד היא באמצעות האטת תדר השעון שלו. בלינוקס ניתן לבחור במנהלי תדר שעון שונים. נבחר בין מצבים powersave ו-performance. במכונות הניסוי, תדר השעון כמעט נחלק לשניים במעבר למצב powersave. כדי להחליף לכל הליבות את התדר השתמשו בפקודה:</p>
<pre><code>for core in $(seq 0 3) ; do sudo cpufreq-set -c $core -g $governor ; done</code></pre>
<p>כאשר מחליפים את ‎<code>$governor</code> ב-<code>powersave</code> או <code>performance</code> לפי הצורך. כלי perftest עשויים להדפיס אזהרה כאשר תדר השעון של המעבד אינו תואם לתדר המקסימלי שלו:</p>
<pre><code>Conflicting CPU frequency values detected: 3300.000000 != 1600.000000. CPU Frequency is not max.</code></pre>
<p>ניתן להתעלם מאזהרה זו, או להוסיף את הדגל ‎<code>-F</code> כדי לבטל את האזהרה.</p>
<p>מדדו את קצב השליחה כאשר לשרת תדר שעון נמוך ותדר גבוה והשוו את התוצאות כאשר משתמשים בפעולות RDMA Write לעומת פעולות RDMA Send/Receive.</p>
<p>מדוע נרצה להשתמש בתדר שעון נמוך מהרגיל?</p>
<h2 id="תרגיל-4-ריבוי-ליבות-multi-core-processing">תרגיל 4: ריבוי ליבות (Multi-core Processing)</h2>
<p>כאשר צוואר הבקבוק בניסוי הוא העומס על המעבד הראשי, נוכל להשיג שיפור ביצועים וקצב העברה גבוה יותר באמצעות ניצול מספר ליבות של המעבד. הזכרו בתוצאות <a href="#lstopo">lstopo</a> ובמבנה המערכת שמצאתם באמצעותה. יש להבחין בין ליבות נפרדות ובין חוטים החולקים את אותה ליבת מעבד באמצעות Simultaneous multithreading (SMT) / Hyperthreading.</p>
<p>בניסוי הבא נפעיל מספר תוכניות במקביל. ניתן לעשות זאת באמצעות פתיחה של מספר לשוניות במסוף (צירוף המקשים ‎<kbd>Ctrl</kbd> + <kbd>Shift</kbd>+<kbd>T</kbd>‎). תוכלו לפתוח מספר לשוניות גם עבור התחנה המרוחקת, ולהשתמש בכלי ssh כדי לפתוח מספר חיבורים מקבילים לאותה תחנה.</p>
<p>כדי לראות את השפעת מספר התהליכים על קצב ההעברה, שרטטו גרף המשווה את קצב ההעברה (הודעות לשניה) כפונקציה של מספר התהליכים. הפעילו תהליך נפרד של <code>ib_send_bw</code> על כל אחת מהליבות בשרת (באמצעות taskset). כדי למנוע התנגשויות בבחירת פורט הגישה לתהליכים השונים, השתמשו בפרמטר ‎<code>-p</code> על מנת לבחור פורט שונה לכל תהליך. באופן דומה, הפעילו עותק נפרד של לקוחות <code>ib_send_bw</code> כאשר כל לקוח פונה לשרת שונה. השתמשו בגודל הודעות קטן (פרמטר ‎<code>-s</code>) של 4 בתים. מדדו את סך קצב ההעברה של כל הלקוחות (הודעות לשניה), ואת ניצולת המעבדים הכוללת.</p>
<p>כעת חזרו על הניסוי אבל תוך שימוש בגודל הודעה גדול (65536 בתים). הסבירו את ההבדלים בין גדלי ההודעות השונים. מהו צוואר הבקבוק בכל ניסוי?</p>
<h1 id="חלק-שני---תכנות-rdma"><a name="חלק-ב"/> חלק שני - תכנות RDMA</h1>
<p>בחלק זה של הניסוי נתנסה בתכנות RDMA בשפת C באמצעות הספריה librdmacm. נשנה תוכנית דוגמה המממשת מסד נתונים מפושט עם תקשורת דו-צדדית, ונלמד כיצד להחליף חלק מן הפעולות בפעולות גישה לזכרון מרוחק על מנת לשפר את ביצועי המערכת.</p>
<p>המכונות שעליהן תבצעו את הניסוי הן משותפות, ולכן לפני תחילת העבודה צרו תיקיה תחת תיקית הבית הכוללת את שמות הסטודנטים בשם התיקיה:</p>
<pre><code>cd ~
mkdir $student_names
cd $student_names</code></pre>
<p>הורידו את קוד הדוגמה שממנו נתחיל באמצעות הפקודה:</p>
<pre><code>git clone https://github.com/haggaie/rdma-experiment.git</code></pre>
<p>הפעולה תעתיק את הקבצים לתיקיה rdma-experiment/src. תוכנית הדוגמה היא שרת מסד נתונים מפושט. מסד הנתונים מצמיד ערכים למפתחות, ומאפשר שליפה של ערך בהינתן המפתח המתאים. הדוגמה מורכבת מתוכנית שרת <code>exp_server</code>, המקבלת בקשות כתיבה וקריאה של נתונים ושומרת אותם במערך בזיכרון, ותוכנית לקוח <code>exp_client</code> המאפשרת למשתמש לשמור ולקרוא מפתחות בצורה אינטראקטיבית.</p>
<p>על מנת לבנות את התוכנית, הפעילו את הסקריפט build.sh הנמצא בתיקיה rdma-experiment/src. לאחר מכן התוכניות המוכנות צריכות להמצא בתיקיה rdma-experiment/src/build. כדי להפעיל את התוכניות, הפעילו את תוכנית השרת על מחשב השרת:</p>
<pre><code>exp_server [-p port_number]</code></pre>
<p>ניתן לבחור מספר פורט שונה באמצעות הפרמטר ‎<code>-p</code>, למשל אם חולקים את השרת עם מספר משתמשים.</p>
<p>את תוכנית הלקוח יש להפעיל עם כתובת ה-IP של השרת:</p>
<pre><code>exp_client -s $server_ip [-p port_number]</code></pre>
<p>תוכנית הלקוח מבקשת קלט מהמשתמש בצורה מחזורית. בכל פעם יש לבחור את סוג ההודעה – כתיבה למסד הנתונים, קריאה מתוכו, או סיום הריצה. אם המשתמש מבקש לכתוב או לקרוא, התוכנית מבקשת את המפתח והערך המתאימים לפי הצורך, ומציגה את הפלט המתקבל מהשרת בתגובה.</p>
<h3 id="ספרית-rdmacm">ספרית rdmacm</h3>
<p>התוכנית משתמשת בספריות rdmacm ו-ibverbs המשמשות לתכנות RDMA. היא כוללת את האובייקטים הבאים:</p>
<table style="width:99%;">
<colgroup>
<col width="14%" />
<col width="85%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">מזהה חיבור <code>rdma_cm_id</code> (ID)‎</td>
<td align="left">מזהה את החיבור עם הצד השני ברשת, ומאפשר לבצע מולו פעולות של שליחה וקבלה.</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">לכל ID יש תור שליחה הכולל הודעות לשליחה לצד השני (כולל פעולות גישה לזכרון מרוחק) ותור קבלה הכולל חוצצי זכרון המיועדים לקבלת הודעות.</td>
</tr>
<tr class="odd">
<td align="left">זכרון רשום memory region (MR)‎</td>
<td align="left">כדי לאפשר לכרטיס הרשת גישה ישירה לזכרון, יש לרשום את הזכרון המבוקש מראש. לאחר הרישום מתקבל אוביקט MR המייצג את הזכרון הרשום.</td>
</tr>
<tr class="even">
<td align="left">השלמת משימה work completion (WC)‎</td>
<td align="left">לאחר ביצוע פעולת שליחה או קבלה בהצלחה, מתווספים נתוני השלמת משימה לתור פנימי המשוייך ל-ID. התוכנית יכולה לקרוא את הנתונים מהתור וכך לזהות שהפעולה הושלמה. רק לאחר השלמת הפעולה וקבלת הנתונים מותר לתוכנית לעשות שימוש בזכרון המשוייך לפעולה.</td>
</tr>
</tbody>
</table>
<h3 id="קריאה-מרחוק">קריאה מרחוק</h3>
<p>כדי להקל את העומס על השרת נשנה את פעולות הקריאה של מסד הנתונים. במקום לשלוח הודעה לשרת בבקשה לקרוא ערך כלשהו, נשתמש בפעולת RDMA Read על מנת לקרוא את הזכרון המרוחק ללא מעורבות של תוכנית השרת.</p>
<p>על מנת לשלוח פעולת קריאה, יש להשתמש בפונקציה <code>rdma_post_read</code>. פעולה זו מקבלת כפרמטר את זהות החיבור אל השרת (id), כתובת ואורך של איזור בזכרון המקומי אליו תועתק התשובה,</p>
<p>כדי לאפשר זאת, תוכנית השרת כבר רושמת את טבלת מסד הנתונים (המשתנה table בקובץ <code>database.c</code>), ושולחת את פרטי ה-MR לתוכנית הלקוח. הפרטים שמורים במשתנה <code>db_info</code> בקובץ <code>rdma_client.c</code>. על מנת שכרטיס הרשת יוכל לכתוב את תוצאת הקריאה הפעולה מקבלת גם כתובת יעד מקומית. גם כתובת זו צריכה להיות באיזור זכרון רשום (MR). תוכלו להשתמש למשל ב-MR הקיים <code>recv_mr</code> הכולל את המשתנה <code>recv_msg</code>.</p>
<p>ערכו את הפונקציה <code>rdma_read</code> ב-<code>rdma_client.c</code>, כך שתשלח בקשה לקריאת זכרון מרוחק של השרת. תוכלו להסתכל בפונקציות <code>rpc</code> ו-<code>transmit_message</code> על מנת לראות כיצד התוכנית שולחת הודעות לשרת ומקבלת תשובות.</p>
<h3 id="ניפוי-שגיאות">ניפוי שגיאות</h3>
<p>על מנת לנפות שגיאות, ניתן להשתמש בתוכנית <code>gdb</code>. כדי לבנות גרסה מתאימה של התוכנית ניתן לערוך את <code>build.sh</code> ולהוסיף את הפרמטר ‎<code>-DCMAKE_BUILD_TYPE=Debug</code> לפקודה <code>cmake</code>.</p>
<p>קודי שגיאה המוחזרים מספרית <code>librdmacm</code> במשתנה <code>errno</code> הם קודים סטנדרטיים של POSIX. ניתן למצוא את רשימת ערכי השגיאה ב-<a href="http://man7.org/linux/man-pages/man3/errno.3.html">errno(3)‎</a>. ערכי השגיאה המתקבלים עם השלמת פעולת קבלה, שליחה או RDMA בשדה <code>ibv_wc.status</code> מופיעים ב<a href="http://www.rdmamojo.com/2013/02/15/ibv_poll_cq/">עמוד ההסבר לפונקציה <code>ibv_poll_cq</code></a> בבלוג RDMAmojo.</p>
<h3 id="מדידת-ביצועים">מדידת ביצועים</h3>
<p>שנו את תוכנית הלקוח כך שתבצע מספר רב של פעולות קריאה (100,000), ללא אינטראקציה עם המשתמש (יש לבטל הדפסות בתוכנית באמצעות הפרמטר ‎-q), ומספר רב של פעולות עדכון. מדדו את הזמן שלוקח לבצע:</p>
<ol style="list-style-type: decimal">
<li>פעולות עדכון</li>
<li>פעולות קריאה (שליחה וקבלת הודעות באמצעות <code>rpc()</code>‎)</li>
<li>פעולות קריאה (באמצעות RDMA)</li>
</ol>
<p>השתמשו בפונקציה <a href="https://linux.die.net/man/3/clock_gettime"><code>clock_gettime</code></a> עם הפרמטר <code>CLOCK_MONOTONIC</code> כדי לקרוא את הזמן הנוכחי לפני ואחרי המדידה.</p>
<h1 id="נספח-א---הכנה-לניסוי">נספח א' - הכנה לניסוי</h1>
<p>ניתן להשתמש במכונה וירטואלית כדי לדמות כרטיס רשת בעל יכולות RDMA. הורידו את הגדרות המכונה באמצעות:</p>
<p>git clone <a href="https://github.com/haggaie/rdma-experiment" class="uri">https://github.com/haggaie/rdma-experiment</a></p>
<p>יש להתקין את <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a> ואת <a href="https://www.vagrantup.com/downloads.html">Vagrant</a> (גרסה 2.0.3 ומעלה).</p>
<p>הפעילו את המכונות באמצעות vagrant up. בפעם הראשונה ההורדה וההתקנה עשויה לקחת זמן.</p>
<p>כעת לרשותכם שתי מכונות וירטואליות בשמות client ו-server המחוברות ברשת וירטואלית. תוכלו להתחבר לכל אחת מהן באמצעות vagrant ssh client או vagrant ssh server.</p>
<p>בעת העבודה עם SoftRoCE (בעבודת ההכנה בבית) יש להפעיל את RoCE לאחר כל הפעלה מחדש של המכונה באמצעות הפקודה:</p>
<pre><code>sudo rxe_cfg start</code></pre>
</body>
</html>
