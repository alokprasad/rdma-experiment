<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="markdown.css" type="text/css" />
</head>
<body>
<h1 id="מעבדה-בתקשורת-rdma">מעבדה בתקשורת RDMA</h1>
<h2 id="מטרות-הניסוי">מטרות הניסוי</h2>
<ol style="list-style-type: decimal">
<li><p>חשיפה לטכנולוגית RDMA</p></li>
<li><p>הבנת מערכות Kernel bypass</p></li>
<li><p>הבנת יתרונות offloading</p></li>
<li><p>הכרות עם מודל התכנות של RDMA</p></li>
</ol>
<h2 id="מתווה-הניסוי">מתווה הניסוי</h2>
<ul>
<li><p>מונחים בסיסיים</p>
<ul>
<li><p>Latency &amp; bandwidth</p></li>
<li><p>CPU affinity, CPU utilization, offloading, kernel bypass</p></li>
<li><p>עצמים של RDMA: QP, CQ, WR, MR</p></li>
</ul></li>
<li><p>כלי מדידה</p>
<ul>
<li><p>sockperf</p></li>
<li><p>Perftool</p></li>
<li><p>VMA</p></li>
</ul></li>
<li><p>ניסויים</p>
<ul>
<li><p>מדידת latency, bandwidth עבור גדלי הודעות שונים, עבור TCP (עם VMA או בלעדיו) ו-RC</p></li>
<li><p>עבור גודל מסוים, השוואת ניצול המעבד בצד השולח והמקבל, בין sockperf עם VMA ובלעדיו, ונבחן את ההשפעה של הורדת תדר השעון של המעבד על קצב התקשורת.</p></li>
<li><p>ib_send_bw, ib_write_bw</p></li>
<li><p>ריבוי ליבות: שימוש ב-affinity כדי להצמיד חוטי לקוח ושרת לליבות מתאימות ומדידת throughput ו-latency כולל.</p></li>
</ul></li>
</ul>
<h2 id="תיאור-תמציתי-של-הניסוי">תיאור תמציתי של הניסוי</h2>
<p>על מנת לאפשר לשרתים לעבוד בקצבי תקשורת הולכים וגדלים, כרטיסי תקשורת מודרניים מאפשרים מעקף של ליבת מערכת ההפעלה וממשק ישיר בין תהליכי משתמש ובין החומרה. בנוסף חלק ממשימות התקשורת מואצות על גבי כרטיס הרשת כדי להפחית מהעומס על המעבד הראשי. בניסוי נלמד כיצד פועלים מנגנונים אלה, ונמדוד את השפעתם על הביצועים של יישומי תקשורת. על מנת ללמוד כיצד לפתח יישומי RDMA בשפת C, נבנה במהלך הניסוי מערכת המשתפת את זיכרון השרת באמצעות RDMA ללקוחות קצה.</p>
<h2 id="רקע">רקע</h2>
<h3 id="מעקף-ליבת-מערכת-ההפעלה">מעקף ליבת מערכת ההפעלה</h3>
<p>מערכות הפעלה על פי רוב לוקחות על עצמן את מימוש פרוטוקולי התקשורת של שכבות הרשת (IP) וה-Transport ‏(TCP), ומציגות בפני תוכניות משתמש ממשק מופשט של תקשורת (sockets). מערכת ההפעלה היא היחידה בעלת הגישה לכרטיס הרשת, ולכן תפקיד נוסף שלה היא לסווג את החבילות המתקבלות ולשייך אותן לתוכנית המשתמש המתאימה.</p>
<p>גישה זו משחררת את המתכנת מעול המימוש של הפרוטוקולים השונים, ומהיכרות עם פרטי כרטיס הרשת המסוים המותקן במחשב. אולם, לגישה זו מספר חסרונות: שליחה וקבלה של מידע כוללת החלפות הקשר של המעבד, מן ההקשר של תהליך המשתמש, אל מערכת ההפעלה, ובחזרה. החלפת הקשר מעכבת את ביצוע תוכנית המשתמש, ובמהלכה אובד חלק ממצב המעבד, מה שפוגע בביצועי המערכת.</p>
<p>מכיוון שמערכת ההפעלה היא היחידה המתקשרת עם כרטיס הרשת, מידע שנשלח מתוכנית המשתמש ראשית מועתק לזיכרון של ליבת מערכת ההפעלה, ורק לאחר מכן נשלח לרשת. בדומה לכך מידע שמתקבל מן הרשת מושם בזיכרון של הליבה, ורק לאחר שמערכת ההפעלה מסווגת אותו הוא מועתק לזיכרון תהליך המשתמש. ההעתקה של המידע מעכבת את קבלתו ושליחתו, ומשתמשת במעבד שהיה יכול לבצע חישובים מועילים יותר באותו הזמן.</p>
<p>כרטיסי תקשורת חדשים יותר מסוגלים לעבוד עם תוכניות משתמש באופן ישיר, ללא מעורבות של מערכת ההפעלה. באמצעות מערכת מיפוי זיכרון מקבילה ל- memory management unit (MMU) של המעבד הראשי. כשם שהמעבד הראשי מתרגם כתובות זכרון וירטואליות ממרחב הזכרון של התהליך הנוכחי למרחב הזכרון הפיזי, כך כרטיס הרשת גם הוא משתמש בזיכרון וירטואלי ומסוגל להפריד בין תהליכים שונים. עקב כך תוכנית המשתמש יכולה לתת הוראות קבלה או שליחה עם כתובות במרחב הווירטואלי שלה, ישירות לכרטיס. הכרטיס מוודא שהכתובות חוקיות, ומבצע את ההוראות. מערכת ההפעלה מעורבת רק בזמן יצירת התקשורת הישירה בין תוכנית המשתמש לכרטיס הרשת.</p>
<p>בניסוי נראה כיצד שימוש בספריית VMA המממשת פרוטוקולי תקשורת בסביבת המשתמש משפרת ביצועים לתוכניות רשת. הספרייה מממשת פרוטוקולי TCP/IP באמצעות גישה ישירה לכרטיס הרשת, ומחליפה באופן שקוף את ממשקי המשתמש של מערכת ההפעלה.</p>
<h3 id="האצת-פרוטוקולי-רשת">האצת פרוטוקולי רשת</h3>
<p>לעתים עקיפת מערכת ההפעלה אינה מספיקה כדי לתת את הביצועים הנדרשים. כדי להפחית עוד יותר מהעומס על המעבד הראשי בפעולות תקשורת, מעבירים חלק ממימוש שכבות הרשת וה-Transport לכרטיס הרשת. חומרת כרטיס הרשת מסוגלת לבצע את העיבוד הנדרש במקביל למעבד הראשי, וכך הוא מתפנה לבצע משימות אחרות. בניסוי זה אנחנו מתמקדים בפרוטוקולים ממשפחת RoCE – RDMA over Converged Ethernet, תוך שימוש במעקף ליבת מערכת ההפעלה בנוסף להאצת פרוטוקול הרשת.</p>
<p>כאשר שולחים או מקבלים הודעות, פרוטוקול reliable connected (RC) ממשפחת RoCE מאפשר לתוכנית המשתמש לספק הודעות גדולות לשליחה (עד 2GB), או חוצצים גדולים לקבלת הודעות, ולהסתמך על כרטיס הרשת לנהל את הפרוטוקול בחומרה. כרטיס הרשת מטפל בחלוקת ההודעה לחבילות, שליחת אישורי קבלה, סידור ההודעות המתקבלות ושליחה חוזרת במקרים של אובדן חבילות. כך מתפנה המעבד הראשי לביצוע חישובים של תוכנית המשתמש.</p>
<p>טכנולוגית RDMA (Remote Direct Memory Access) מאפשרת גם גישה ישירה לזיכרון מרוחק. אנחנו מתייחסים לתחנות הקצה בתור היוזם והיעד. היוזם מבקש לשלוח מידע אל היעד, או למשוך ממנו מידע. היעד מקבל את הבקשה ומאחסן את המידע שהתקבל (אם מדובר בשליחה), או שולח את התשובה (אם מדובר בבקשה לקריאה). מבחינים בין תקשורת דו-צדדית ותקשורת חד-צדדית, לפי מידת המעורבות של המעבד הראשי בצד היעד. בתקשורת דו-צדדית הצד היוזם שולח הודעה אל היעד, והיעד מספק חוצץ זכרון לקבלת ההודעה ומקבל התראה על קבלתה. לעומת זאת, בתקשורת חד-צדדית, הצד היוזם מסוגל לגשת לזכרון מרוחק באופן ישיר. הצד היוזם שולח הוראה לבצע כתיבה או קריאה של זיכרון השייך ליעד, וכרטיס הרשת של היעד מבצע את ההוראה מבלי לערב את המעבד הראשי.</p>
<p>בניסוי נבחן את ההשפעה של שימוש בהאצת חומרה של פרוטוקול הרשת על הביצועים, ונכתוב תכנית שרת-לקוח פשוטה המשתמשת ב-RDMA על מנת לשתף זיכרון מרוחק.</p>
<h2 id="חומר-רקע-נוסף">חומר רקע נוסף</h2>
<p>חומר רקע לגבי טכנולוגית RDMA ומעקף ליבת מערכת ההפעלה ניתן למצוא בשקפים המצורפים מתוך קורס RDMA באוניברסיטה העברית.</p>
<p>מידע נוסף על כלי המדידה אשר בשימוש בניסוי ניתן למצוא במקורות הבאים:</p>
<ul>
<li><p>המדריך למשתמש של sockperf:‏ <a href="https://www.mankier.com/3/sockperf">sockperf man page</a></p></li>
<li><p>כלי cpufrequtils לשליטה בתדר השעון של המעבד: <a href="https://manpages.debian.org/stretch/cpufrequtils/cpufreq-set.1.en.html">man cpufreq-set</a></p></li>
<li><p><a href="https://community.mellanox.com/docs/DOC-2802">תיעוד של חבילת perftest</a> הכוללת כלי מדידת ביצועים לתקשורת RDMA</p></li>
</ul>
<p>ניתן לקרוא על ממשקי התכנות לשימוש ב-RDMA ב<a href="https://www.mellanox.com/related-docs/prod_software/RDMA_Aware_Programming_user_manual.pdf">מדריך לתכנות רשתות RDMA</a> (אנגלית) של מלאנוקס. החלקים הרלוונטיים הינם:</p>
<ul>
<li><p>פרק 2 RDMA-Aware Programming Overview, עמודים 19-24.</p></li>
<li><p>פרק 4 RDMA_CM API. הפונקציות הרלוונטיות למעבדה הן:</p>
<ul>
<li><p>rdma_create_id</p></li>
<li><p>rdma_create_ep</p></li>
<li><p>rdma_listen</p></li>
<li><p>rdma_connect</p></li>
<li><p>rdma_get_request</p></li>
</ul></li>
<li><p>פרק 5 RDMA Verbs API. הפונקציות הרלוונטיות הן:</p>
<ul>
<li><p>rdma_reg_msgs</p></li>
<li><p>rdma_reg_read</p></li>
<li><p>rdma_reg_write</p></li>
<li><p>rdma_post_recv</p></li>
<li><p>rdma_post_send</p></li>
<li><p>rdma_post_read</p></li>
<li><p>rdma_post_write</p></li>
<li><p>rdma_get_send_completion</p></li>
<li><p>rdma_get_recv_completion</p></li>
</ul></li>
</ul>
<h1 id="חלק-ראשון---מדידות-ביצועים">חלק ראשון - מדידות ביצועים</h1>
<h2 id="התמצאות">התמצאות</h2>
<p>על מנת להשתמש במחשבי הניסוי השתמשו במשתמש rdmauser. כדי להשתמש בשורת הפקודה פתחו את ישום המסוף.</p>
<p>במחשב מספר כרטיסי רשת. ניתן לזהות אותם באמצעות הפקודה ip link show. רק שניים מהם תומכים ב-RDMA ובאחד מהם נשתמש בניסוי. מצאו מהם באמצעות הפקודה:</p>
<pre><code>ls /sys/class/infiniband_verbs/uverbs0/device/net/</code></pre>
<p>אלו שני פורטים של כרטיס רשת יחד התומך ב-RDMA. רק אחד מהם מחובר לשרת השני. מצאו את הפורט המחובר באמצעות הסתכלות בפלט של <code>ip link show</code> – הפורט המנותק יופיע עם הדגל <code>NO-CARRIER</code>.</p>
<p>במכונות של הניסוי יופיע הכרטיס כ-eth2.</p>
<p>נסמן את כרטיס הרשת כ-‎$dev. מצאו את כתובת ה-IP של כרטיס זה באמצעות הפקודה ip addr show $dev. נסמן את כתובת ה-IP של השרת ‎<code>$server_ip</code> הלקוח ‎<code>$client_ip</code>.</p>
<p>תוכלו להגדיר את שם הכרטיס וכתובות ה-ip כמשתני סביבה כדי להקל על הקלדתם. לדוגמה:</p>
<pre><code>dev=eth2
server_ip=192.168.0.101
client_ip=192.168.0.102</code></pre>
<p>בדקו את מהירות כרטיס הרשת שמצאתם באמצעות הפקודה:</p>
<pre><code>ethtool $dev</code></pre>
<h3 id="ריבוי-ליבות">ריבוי ליבות</h3>
<p>מערכת ההפעלה לינוקס מנסה לאזן את העומס על ליבות המעבד השונות, ולעתים זה מחליפה את הליבה שעליה רץ תהליך מסוים. כדי למנוע החלפות שכאלה במהלך כל ניסוי, נעדיף לקבוע עבור מערכת ההפעלה שיש להשתמש בליבה מסוימת בכל ניסוי. לשם כך נשתמש בכלי <code>taskset</code>. הכלי מקבל פרמטר ‎-c ולאחריו את מספר הליבה שעליה יש להריץ את התוכנית המבוקשת. כך למשל על מנת להריץ את <code>ib_send_bw</code> על ליבה מספר 3, נפעיל את הפקודה:</p>
<pre><code>taskset -c 3 ib_send_bw …</code></pre>
<p>שימו לב: יש להוסיף את הפקודה <code>taskset</code> לפני כל פקודה שצריכה להעשות על ליבה מסוימת.</p>
<h3 id="חיבור-מרוחק">חיבור מרוחק</h3>
<p>במהלך הניסוי תעבדו על שתי המכונות במקביל. כדי להקל על העבודה, התחברו מן אחת המכונות אל השניה בחיבור מרוחק ssh המאפשר שימוש בשורת הפקודה של המכונה המרוחקת:</p>
<pre><code>ssh &lt;hostname / ip address&gt;</code></pre>
<p>מומלץ לפתוח שני חלונות מסוף: אחד עבור המכונה המקומית, ואחד עבור המכונה המרוחקת.</p>
<h3 id="tcp-ומעקף-ליבת-מערכת-ההפעלה">TCP ומעקף ליבת מערכת ההפעלה</h3>
<p>בחלק זה של הניסוי נשתמש בכדי למדידת ביצועים של פרוטוקול TCP בשם sockperf. בצד השרת הפקודה המתאימה היא:</p>
<pre><code>sockperf server --tcp</code></pre>
<p>בצד הלקוח הפעילו את sockperf למדידת קצב העברת הנתונים באמצעות בדיקת throughput של sockperf. במצב זה התוכנית מנסה לשלוח את המספר המירבי של בתים לצד השני עד לגודל חלון ה-TCP. הפעילו את הפקודה:</p>
<pre><code>sockperf throughput --tcp -i \$server\_ip --msg-size 1472 -t 5</code></pre>
<p>אנו משתמשים בגודל הודעה מקסימלי (1472) על מנת לקבל קצב העברה גבוה יותר ולהפחית היחס בין כמות העבודה הנדרשת מן המעבד למספר הבתים המועברים. ניתן לשלוט במשך זמן הניסוי באמצעות הפרמטר -t.</p>
<p>במהלך הריצה, מדדו גם את ניצולת המעבד באמצעות הכלי <code>top</code> או הכלי הגרפי System Monitor. בכלי <code>top</code> תוכלו להציג את ניצול כל ליבה בנפרד באמצעות לחיצה על המקש <kbd>1</kbd>. הכלי מציג (בשורה השלישית של הפלט) בנפרד את העומס בשל תוכניות משתמש (<code>us</code>) ותוכניות משתמש בעדיפות נמוכה (<code>ni</code>), ליבת מערכת ההפעלה (<code>sy</code>), המתנה לקלט/פלט (<code>wa</code>). אחוז הזמן של המעבד בו הוא ממתין ללא פעילות מופיע תחת <code>id</code>.</p>
<h3 id="השהיית-רשת">השהיית רשת</h3>
<p>למדידת השהיית הרשת, נפעיל את <code>sockperf</code> במצב <code>ping-pong</code> בו כל הודעה נשלחת רק לאחר קבלת ההודעה הקודמת (החליפו את הפרמטר <code>throughput</code> ב-<code>ping-pong</code>). כך מדידת זמן ההעברה הכולל מאפשר למדוד את השהיית הרשת בין שתי התחנות. השתמשו בפרוטוקול UDP המתאים יותר למדידת השהייה על ידי השמטת הפרמטר ‎<code>--tcp</code> משורת הפקודה של <code>sockperf</code> (בצד השרת ובצד הלקוח), ובחרו גודל הודעה מינימלי (14 בתים) כדי למדוד את השהיית הרשת ללא זמן השידור.</p>
<h3 id="מעקף-ליבה">מעקף ליבה</h3>
<p>עד עתה השתמשנו במימוש של פרוטוקול TCP בתוך ליבת מערכת ההפעלה. כעת נחליף אותו על ידי שימוש בספריית VMA במימוש העוקף את ממשקי מערכת ההפעלה ומתקשר ישירות עם כרטיס הרשת. כדי לגרום לתוכנית להשתמש ב-VMA נגדיר זמנית את משתנה הסביבה LD_PRELOAD=libvma.so. כדי לקבל הרשאה לגישה ישירה לכרטיס הרשת, עלינו לקבל הרשאה של משתמש-על באמצעות הפקודה sudo. לסיכום על מנת להפעיל את sockperf נשתמש בפקודה:</p>
<pre><code>sudo env LD_PRELOAD=libvma.so sockperf …</code></pre>
<p>השתמשו ב-VMA בצד השרת ובצד הלקוח. מדדו קצב ההעברה ואת השהיית הרשת תוך שימוש בספריית VMA. מדדו גם את ניצולת המעבד. השוו את התוצאות והסבירו את התוצאות שקיבלתם.</p>
<p>הערה: VMA עשוי להדפיס אזהרה על כך שאין דפים גדולים huge pages זמינים במכונה. ניתן להתעלם מאזהרה זו.</p>
<h3 id="האטת-קצב-המעבד">האטת קצב המעבד</h3>
<p>דרך אחרת לבחון את ניצולת המעבד היא באמצעות האטת תדר השעון שלו. בלינוקס ניתן לבחור במנהלי תדר שעון שונים. נבחר בין מצבים powersave ו-performance. במכונות הניסוי, תדר השעון כמעט נחלק לשניים במעבר למצב powersave. כדי להחליף לכל הליבות את התדר השתמשו בפקודה:</p>
<pre><code>for core in $(seq 0 3) ; do sudo cpufreq-set -c $core -g $governor ; done</code></pre>
<p>כאשר מחליפים את ‎<code>$governor</code> ב-<code>powersave</code> או <code>performance</code> לפי הצורך.</p>
<p>מדדו את קצב השליחה בתדר שעון נמוך ובתדר גבוה והשווה את התוצאות כאשר משתמשים ב-VMA וכאשר משתמשים בליבת מערכת ההפעלה.</p>
<p>מדוע נרצה להשתמש בתדר שעון נמוך מהרגיל?</p>
<h2 id="שימוש-בפרוטוקול-roce">שימוש בפרוטוקול RoCE</h2>
<p>כעת נבחן את השימוש בפרוטוקול תקשורת מואץ בחומרה, כתחליף ל-TCP. נשתמש באוסף ישומי perftest למדידת ביצועי RoCE.</p>
<p>למדידת קצב העברה נשתמש בכלי ib_send_bw. על השרת, נפעיל את הכלי ללא פרמטרים נוספים:</p>
<pre><code>ib_send_bw</code></pre>
<p>בצד הלקוח (השולח), נפעיל את הכלי עם כתובת השרת כפרמטר:</p>
<pre><code>ib_send_bw $server_ip</code></pre>
<p>ניתן לשלוט במשך הניסוי באמצעות הפרמטר ‎-D. יש להעביר את אותו משך הזמן גם לשרת וגם ללקוח אחרת יתקבלו תוצאות שגויות. בנוסף, perftest עשוי להדפיס אזהרה כאשר תדר השעון של המעבד אינו תואם לתדר המקסימלי שלו. ניתן להתעלם מאזהרה זו.</p>
<p>כעת הריצו את אותו הניסוי אבל תוך שימוש בגודל הודעה קטן (השתמשו בפרמטר -s) של 4 בתים (העבירו את הפרמטר גם לשרת וגם ללקוח). מהו קצב ההעברה שהתקבל, ומדוע?</p>
<p>כדי למדוד את השהיית הרשת, נשתמש בכלי ib_send_lat, הפועל באופן דומה.</p>
<p>מדדו את קצב ההעברה והשהיית הרשת, והשוו את התוצאות לתוצאות שהתקבלו בשימוש ב-VMA. מה מקור ההבדל?</p>
<h3 id="גישה-לזכרון-מרוחק">גישה לזכרון מרוחק</h3>
<p>פרוטוקול RoCE מאפשר גם גישה לזכרון מרוחק ללא מעורבות של המעבד שאליו שייך הזכרון. נדגים זאת באמצעות תוכנית הבדיקה ib_write_bw, בה תוכנית הלקוח מבצעת כתיבות לזכרון של תוכנית השרת. אופן הפעולה שלה זהה לשאר תוכניות perftest.</p>
<p>מדדו את קצב העברת הנתונים באמצעות ib_write_bw תוך שימוש בהודעות גדולות (גודל ברירת המחדל). מדדו במהלך הריצה את ניצול המעבד בצד השרת ובצד הלקוח. הסבירו את ההבדלים בין הצדדים.</p>
<p>אופציונלי: כדי לוודא שהמעבד בצד השרת אינו מעורב, האטו את תדר השעון שלו, ומדדו את קצב ההעברה שנית.</p>
<h3 id="ריבוי-ליבות-1">ריבוי ליבות</h3>
<p>כאשר צוואר הבקבוק בניסוי הוא העומס על המעבד הראשי, נוכל להשיג שיפור ביצועים וקצב העברה גבוה יותר באמצעות ניצול מספר ליבות של המעבד. בדקו באמצעות הפקודה numactl --hardware כמה מעבדים במערכת שברשותכם, וכיצד הם מאורגנים.</p>
<p>בניסוי הבא נפעיל מספר תוכניות במקביל. ניתן לעשות זאת באמצעות פתיחה של מספר לשוניות במסוף (צירוף המקשים ‎<kbd>Ctrl</kbd> + <kbd>Shift</kbd>+<kbd>T</kbd>)‎. תוכלו לפתוח מספר לשוניות גם עבור התחנה המרוחקת, ולהשתמש בכלי ssh כדי לפתוח מספר חיבורים מקבילים לאותה תחנה.</p>
<p>הפעילו תהליך נפרד של ib_send_bw על כל אחת מהליבות בשרת (באמצעות taskset). כדי למנוע התנגשויות בבחירת פורט הגישה לתהליכים השונים, השתמשו בפרמטר -p על מנת לבחור פורט שונה לכל תהליך. באופן דומה, הפעילו עותק נפרד של לקוחות ib_send_bw כאשר כל לקוח פונה לשרת שונה. מדדו את סך קצב ההעברה של כל הלקוחות, ואת ניצולת המעבדים הכוללת.</p>
<p>כעת חזרו על הניסוי אבל תוך שימוש בגודל הודעה קטן (השתמשו בפרמטר -s) של 4 בתים. בדקו את הקצבים המתקבלים עם מספר ליבות בין 1 ל-4, וערכו תרשים המשווה את קצב ההעברה בשני הגדלים. הסבירו את ההבדלים בתרשים בין גדלי ההודעות השונים.</p>
<h1 id="חלק-שני---תכנות-rdma">חלק שני - תכנות RDMA</h1>
<p>בחלק זה של הניסוי נתנסה בתכנות RDMA בשפת C באמצעות הספריה librdmacm. הורידו את קוד הדוגמה שממנו נתחיל באמצעות הפקודה:</p>
<pre><code>git clone https://github.com/haggaie/rdma-experiment.git</code></pre>
<p>הפעולה תעתיק את הקבצים לתיקיה rdma-experiment/src. תוכנית הדוגמה היא שרת מסד נתונים מפושט. מסד הנתונים מצמיד ערכים למפתחות, ומאפשר שליפה של ערך בהינתן המפתח המתאים. הדוגמה מורכבת מתוכנית שרת <code>exp_server</code>, המקבלת בקשות כתיבה וקריאה של נתונים ושומרת אותם במערך בזיכרון, ותוכנית לקוח <code>exp_client</code> המאפשרת למשתמש לשמור ולקרוא מפתחות בצורה אינטראקטיבית.</p>
<p>על מנת לבנות את התוכנית, הפעילו את הסקריפט build.sh הנמצא בתיקיה rdma-experiment/src. לאחר מכן התוכניות המוכנות צריכות להמצא בתיקיה rdma-experiment/src/build. כדי להפעיל את התוכניות, הפעילו את תוכנית השרת על מחשב השרת:</p>
<pre><code>exp_server [-p port_number]</code></pre>
<p>ניתן לבחור מספר פורט שונה באמצעות הפרמטר -p, למשל אם חולקים את השרת עם מספר משתמשים.</p>
<p>את תוכנית הלקוח יש להפעיל עם כתובת ה-IP של השרת:</p>
<pre><code>exp_client -s $server_ip [-p port_number]</code></pre>
<p>תוכנית הלקוח מבקשת קלט מהמשתמש בצורה מחזורית. בכל פעם יש לבחור את סוג ההודעה – כתיבה למסד הנתונים, קריאה מתוכו, או סיום הריצה. אם המשתמש מבקש לכתוב או לקרוא, התוכנית מבקשת את המפתח והערך המתאימים לפי הצורך, ומציגה את הפלט המתקבל מהשרת בתגובה.</p>
<h3 id="ספרית-rdmacm">ספרית rdmacm</h3>
<p>התוכנית משתמשת בספריות rdmacm ו-ibverbs המשמשות לתכנות RDMA. היא כוללת את האובייקטים הבאים:</p>
<table style="width:99%;">
<colgroup>
<col width="12%" />
<col width="86%" />
</colgroup>
<tbody>
<tr class="odd">
<td align="left">מזהה חיבור rdma_cm_id (ID)</td>
<td align="left">מזהה את החיבור עם הצד השני ברשת, ומאפשר לבצע מולו פעולות של שליחה וקבלה.</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">לכל ID יש תור שליחה הכולל הודעות לשליחה לצד השני (כולל פעולות גישה לזכרון מרוחק) ותור קבלה הכולל חוצצי זכרון המיועדים לקבלת הודעות.</td>
</tr>
<tr class="odd">
<td align="left">זכרון רשום memory region (MR)</td>
<td align="left">כדי לאפשר לכרטיס הרשת גישה ישירה לזכרון, יש לרשום את הזכרון המבוקש מראש. לאחר הרישום מתקבל אוביקט MR המייצג את הזכרון הרשום.</td>
</tr>
<tr class="even">
<td align="left">השלמת משימה work completion (WC)</td>
<td align="left">לאחר ביצוע פעולת שליחה או קבלה בהצלחה, מתווספים נתוני השלמת משימה לתור פנימי המשוייך ל-ID. התוכנית יכולה לקרוא את הנתונים מהתור וכך לזהות שהפעולה הושלמה. רק לאחר השלמת הפעולה וקבלת הנתונים מותר לתוכנית לעשות שימוש בזכרון המשוייך לפעולה.</td>
</tr>
</tbody>
</table>
<h3 id="קריאה-מרחוק">קריאה מרחוק</h3>
<p>כדי להקל את העומס על השרת נשנה את פעולות הקריאה של מסד הנתונים. במקום לשלוח הודעה לשרת בבקשה לקרוא ערך כלשהו, נשתמש בפעולת RDMA Read על מנת לקרוא את הזכרון המרוחק ללא מעורבות של תוכנית השרת.</p>
<p>על מנת לשלוח פעולת קריאה, יש להשתמש בפונקציה rdma_post_read. פעולה זו מקבלת כפרמטר את זהות החיבור אל השרת (id), כתובת ואורך של איזור בזכרון המקומי אליו תועתק התשובה,</p>
<p>כדי לאפשר זאת, תוכנית השרת כבר רושמת את טבלת מסד הנתונים (המשתנה table בקובץ database.c), ושולחת את פרטי ה-MR לתוכנית הלקוח. הפרטים שמורים במשתנה db_info בקובץ <code>rdma_client.c</code>.</p>
<p>ערכו את הפונקציה <code>generate_request</code> ב-<code>rdma_client.c</code>, כך שבמקום לשלוח הודעה אל השרת, תשלח בקשה לקריאת זכרון מרוחק של השרת.</p>
<p>הערה: על מנת לנפות שגיאות, ניתן להשתמש בתוכנית gdb. כדי לבנות גרסה מתאימה של התוכנית ניתן לערוך את <code>build.sh</code> ולהוסיף את הפרמטר ‎<code>-DCMAKE_BUILD_TYPE=Debug</code> לפקודה <code>cmake</code>.</p>
<h3 id="מדידת-ביצועים">מדידת ביצועים</h3>
<p>שנו את תוכנית הלקוח כך שתבצע מספר רב של פעולות קריאה (100,000), ללא אינטראקציה עם המשתמש (יש לבטל הדפסות בתוכנית), ומספר רב של פעולות כתיבה. מדדו את הזמן שלוקח לבצע את סוגי הפעולות השונים (למשל באמצעות הפקודה ‎<code>time &lt;cmd&gt;</code>‎), והשוו ביניהם.</p>
<h1 id="נספח-א---הכנה-לניסוי">נספח א' - הכנה לניסוי</h1>
<p>ניתן להשתמש במכונה וירטואלית כדי לדמות כרטיס רשת בעל יכולות RDMA. הורידו את הגדרות המכונה באמצעות:</p>
<p>git clone <a href="https://github.com/haggaie/rdma-experiment" class="uri">https://github.com/haggaie/rdma-experiment</a></p>
<p>יש להתקין את <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a> ואת <a href="https://www.vagrantup.com/downloads.html">Vagrant</a> (גרסה 2.0.3 ומעלה).</p>
<p>הפעילו את המכונות באמצעות vagrant up. בפעם הראשונה ההורדה וההתקנה עשויה לקחת זמן.</p>
<p>כעת לרשותכם שתי מכונות וירטואליות בשמות client ו-server המחוברות ברשת וירטואלית. תוכלו להתחבר לכל אחת מהן באמצעות vagrant ssh client או vagrant ssh server.</p>
<p>בעת העבודה עם SoftRoCE (בעבודת ההכנה בבית) יש להפעיל את RoCE לאחר כל הפעלה מחדש של המכונה באמצעות הפקודה:</p>
<pre><code>sudo rxe_cfg start</code></pre>
</body>
</html>
