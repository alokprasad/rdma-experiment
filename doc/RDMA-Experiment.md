מעבדה בתקשורת RDMA
==================

על מנת לאפשר לשרתים לעבוד בקצבי תקשורת הולכים וגדלים, כרטיסי תקשורת
מודרניים מאפשרים מעקף של ליבת מערכת ההפעלה וממשק ישיר בין תהליכי משתמש
ובין החומרה. בנוסף חלק ממשימות התקשורת מואצות על גבי כרטיס הרשת כדי
להפחית מהעומס על המעבד הראשי. בניסוי נלמד כיצד פועלים מנגנונים אלה,
ונמדוד את השפעתם על הביצועים של יישומי תקשורת. על מנת ללמוד כיצד לפתח
יישומי RDMA בשפת C, נבנה במהלך הניסוי מערכת המשתפת את זיכרון השרת
באמצעות RDMA ללקוחות קצה.

מיקום
-----
הניסוי מתבצע ב**חדר 375** במסדרון בין פישבך למאייר.

תוכן עניינים
------------

1. [חומר רקע](#רקע)
2. [חלק ראשון - מדידות ביצועים](#חלק-א)
3. [חלק שני - תכנות RDMA](#חלק-ב)

רקע <a name="רקע"/>
===================

מעקף ליבת מערכת ההפעלה
----------------------

מערכות הפעלה על פי רוב לוקחות על עצמן את מימוש פרוטוקולי התקשורת של
שכבות הרשת (IP) וה-Transport ‏(TCP), ומציגות בפני תוכניות משתמש ממשק
מופשט של תקשורת (sockets). מערכת ההפעלה היא היחידה בעלת הגישה לכרטיס
הרשת, ולכן תפקיד נוסף שלה היא לסווג את החבילות המתקבלות ולשייך אותן
לתוכנית המשתמש המתאימה.

גישה זו משחררת את המתכנת מעול המימוש של הפרוטוקולים השונים, ומהיכרות עם
פרטי כרטיס הרשת המסוים המותקן במחשב. אולם, לגישה זו מספר חסרונות: שליחה
וקבלה של מידע כוללת החלפות הקשר של המעבד, מן ההקשר של תהליך המשתמש, אל
מערכת ההפעלה, ובחזרה. החלפת הקשר מעכבת את ביצוע תוכנית המשתמש, ובמהלכה
אובד חלק ממצב המעבד, מה שפוגע בביצועי המערכת.

מכיוון שמערכת ההפעלה היא היחידה המתקשרת עם כרטיס הרשת, מידע שנשלח
מתוכנית המשתמש ראשית מועתק לזיכרון של ליבת מערכת ההפעלה, ורק לאחר מכן
נשלח לרשת. בדומה לכך מידע שמתקבל מן הרשת מושם בזיכרון של הליבה, ורק לאחר
שמערכת ההפעלה מסווגת אותו הוא מועתק לזיכרון תהליך המשתמש. ההעתקה של
המידע מעכבת את קבלתו ושליחתו, ומשתמשת במעבד שהיה יכול לבצע חישובים
מועילים יותר באותו הזמן.

כרטיסי תקשורת חדשים יותר מסוגלים לעבוד עם תוכניות משתמש באופן ישיר, ללא
מעורבות של מערכת ההפעלה. באמצעות מערכת מיפוי זיכרון מקבילה ל-
memory management unit (MMU)
של המעבד הראשי. כשם שהמעבד הראשי מתרגם כתובות זכרון וירטואליות ממרחב הזכרון של התהליך
הנוכחי למרחב הזכרון הפיזי, כך כרטיס הרשת גם הוא משתמש בזיכרון וירטואלי ומסוגל להפריד בין תהליכים
שונים. עקב כך תוכנית המשתמש יכולה לתת הוראות קבלה או שליחה עם כתובות במרחב
הווירטואלי שלה, ישירות לכרטיס. הכרטיס מוודא שהכתובות חוקיות, ומבצע את
ההוראות. מערכת ההפעלה מעורבת רק בזמן יצירת התקשורת הישירה בין תוכנית
המשתמש לכרטיס הרשת.

בניסוי נראה כיצד שימוש בספריית VMA המממשת פרוטוקולי תקשורת בסביבת המשתמש
משפרת ביצועים לתוכניות רשת. הספרייה מממשת פרוטוקולי TCP/IP באמצעות גישה
ישירה לכרטיס הרשת, ומחליפה באופן שקוף את ממשקי המשתמש של מערכת ההפעלה.

האצת פרוטוקולי רשת
------------------

לעתים עקיפת מערכת ההפעלה אינה מספיקה כדי לתת את הביצועים הנדרשים. כדי
להפחית עוד יותר מהעומס על המעבד הראשי בפעולות תקשורת, מעבירים חלק ממימוש
שכבות הרשת וה-Transport לכרטיס הרשת. חומרת כרטיס הרשת מסוגלת לבצע את
העיבוד הנדרש במקביל למעבד הראשי, וכך הוא מתפנה לבצע משימות אחרות. בניסוי
זה אנחנו מתמקדים בפרוטוקולים ממשפחת RoCE – RDMA over Converged Ethernet, תוך שימוש במעקף ליבת מערכת ההפעלה בנוסף להאצת פרוטוקול הרשת.

כאשר שולחים או מקבלים הודעות, פרוטוקול
reliable connected (RC)
ממשפחת RoCE
מאפשר לתוכנית המשתמש לספק הודעות גדולות לשליחה (עד 2GB), או חוצצים
גדולים לקבלת הודעות, ולהסתמך על כרטיס הרשת לנהל את הפרוטוקול בחומרה.
כרטיס הרשת מטפל בחלוקת ההודעה לחבילות, שליחת אישורי קבלה, סידור ההודעות
המתקבלות ושליחה חוזרת במקרים של אובדן חבילות. כך מתפנה המעבד הראשי
לביצוע חישובים של תוכנית המשתמש.

טכנולוגית RDMA (Remote Direct Memory Access) מאפשרת גם גישה ישירה
לזיכרון מרוחק. אנחנו מתייחסים לתחנות הקצה בתור היוזם והיעד. היוזם מבקש לשלוח מידע אל היעד, או למשוך ממנו מידע.
היעד מקבל את הבקשה ומאחסן את המידע שהתקבל (אם מדובר בשליחה), או שולח את התשובה (אם מדובר בבקשה לקריאה).
מבחינים בין תקשורת דו-צדדית ותקשורת חד-צדדית, לפי מידת המעורבות של המעבד הראשי בצד היעד. בתקשורת
דו-צדדית הצד היוזם שולח הודעה אל היעד, והיעד מספק חוצץ זכרון לקבלת
ההודעה ומקבל התראה על קבלתה. לעומת זאת, בתקשורת חד-צדדית, הצד היוזם מסוגל לגשת לזכרון מרוחק באופן ישיר.
הצד היוזם שולח הוראה לבצע כתיבה או קריאה של זיכרון השייך ליעד, וכרטיס הרשת
של היעד מבצע את ההוראה מבלי לערב את המעבד הראשי.

בניסוי נבחן את ההשפעה של שימוש בהאצת חומרה של פרוטוקול הרשת על הביצועים,
ונכתוב תכנית שרת-לקוח פשוטה המשתמשת ב-RDMA על מנת לשתף זיכרון מרוחק.

חומר רקע נוסף
-------------

חומר רקע לגבי טכנולוגית RDMA ומעקף ליבת מערכת ההפעלה ניתן למצוא בשקפים
המצורפים מתוך קורס RDMA באוניברסיטה העברית.

מידע נוסף על כלי המדידה אשר בשימוש בניסוי ניתן למצוא במקורות הבאים:

-   המדריך למשתמש של sockperf:‏ [sockperf man
    page](https://www.mankier.com/3/sockperf)

-   כלי cpufrequtils לשליטה בתדר השעון של המעבד: [man
    cpufreq-set](https://manpages.debian.org/stretch/cpufrequtils/cpufreq-set.1.en.html)

-   [תיעוד של חבילת
    perftest](https://community.mellanox.com/docs/DOC-2802) הכוללת כלי
    מדידת ביצועים לתקשורת RDMA

ניתן לקרוא על ממשקי התכנות לשימוש ב-RDMA ב[מדריך לתכנות רשתות
RDMA](https://www.mellanox.com/related-docs/prod_software/RDMA_Aware_Programming_user_manual.pdf)
(אנגלית) של מלאנוקס. החלקים הרלוונטיים הינם:

-   פרק 2 RDMA-Aware Programming Overview, עמודים 19-24.

-   פרק 4 RDMA\_CM API. הפונקציות הרלוונטיות למעבדה הן:

    -   `rdma_create_id`

    -   `rdma_create_ep`

    -   `rdma_listen`

    -   `rdma_connect`

    -   `rdma_get_request`

-   פרק 5 RDMA Verbs API. הפונקציות הרלוונטיות הן:

    -   `rdma_reg_msgs`

    -   `rdma_reg_read`

    -   `rdma_reg_write`

    -   `rdma_post_recv`

    -   `rdma_post_send`

    -   `rdma_post_read`

    -   `rdma_post_write`

    -   `rdma_get_send_completion`

    -   `rdma_get_recv_completion`

<a name="חלק-א"/> חלק ראשון - מדידות ביצועים
==========================

תרגיל 1: התמצאות
-------

בתרגיל זה נכיר את תכונות המערכת שעליה נבצע את הניסוי.

על מנת להשתמש במחשבי הניסוי השתמשו במשתמש rdmauser. כדי להשתמש בשורת
הפקודה פתחו את ישום המסוף.

במחשב מספר כרטיסי רשת. ניתן לזהות אותם באמצעות הפקודה ip link show. רק
שניים מהם תומכים ב-RDMA ובאחד מהם נשתמש בניסוי. מצאו מהם באמצעות הפקודה:

    ls /sys/class/infiniband_verbs/uverbs0/device/net/

אלו שני פורטים של כרטיס רשת יחד התומך ב-RDMA. רק אחד מהם מחובר לשרת
השני. מצאו את הפורט המחובר באמצעות הסתכלות בפלט של `ip link show` – הפורט
המנותק יופיע עם הדגל `NO-CARRIER`.

במכונות של הניסוי יופיע הכרטיס כ-eth2.

נסמן את כרטיס הרשת כ-&lrm;`$dev`.
מצאו את כתובת ה-IP של כרטיס זה באמצעות
הפקודה `ip addr show $dev`. נסמן את כתובת ה-IP של השרת
&lrm;`$server_ip`
הלקוח
&lrm;`$client_ip`.

תוכלו להגדיר את שם הכרטיס וכתובות ה-ip כמשתני סביבה כדי להקל על הקלדתם. לדוגמה:

    dev=eth2
    server_ip=192.168.0.101
    client_ip=192.168.0.102

#### שאלה 1.1

בדקו את מהירות כרטיס הרשת שמצאתם באמצעות הפקודה:

    ethtool $dev

מהי מהירות הכרטיס?

### ריבוי ליבות

#### <a name="lstopo"> שאלה 1.2

הציגו את מבנה המחשב עליו אתם עובדים באמצעות הפקודה `lstopo`.
כמה מעבדים יש במכונה? כמה ליבות יש במכונה? כמה חוטים?
האם הזכרון מחובר בחיבור אחיד או בארכיטקטורת
NUMA (Non-uniform memory architecture)&lrm;?

מערכת ההפעלה לינוקס מנסה לאזן את העומס על ליבות המעבד השונות, ולעתים זה
מחליפה את הליבה שעליה רץ תהליך מסוים. כדי למנוע החלפות שכאלה במהלך כל
ניסוי, נעדיף לקבוע עבור מערכת ההפעלה שיש להשתמש בליבה מסוימת בכל ניסוי.
לשם כך נשתמש בכלי `taskset`. הכלי מקבל פרמטר
&lrm;-c
ולאחריו את מספר הליבה
שעליה יש להריץ את התוכנית המבוקשת. כך למשל על מנת להריץ את `ib_send_bw`
על ליבה מספר 3, נפעיל את הפקודה:

    taskset -c 3 ib_send_bw …

שימו לב: יש להוסיף את הפקודה `taskset` לפני כל פקודה שצריכה להעשות על ליבה מסוימת.

### חיבור מרוחק

במהלך הניסוי תעבדו על שתי המכונות במקביל. כדי להקל על העבודה, התחברו מן
אחת המכונות אל השניה בחיבור מרוחק ssh המאפשר שימוש בשורת הפקודה של
המכונה המרוחקת:

    ssh <hostname / ip address>

מומלץ לפתוח שני חלונות מסוף: אחד עבור המכונה המקומית, ואחד עבור המכונה
המרוחקת.

תרגיל 2: TCP ומעקף ליבת מערכת ההפעלה
------------------------------------

בחלק זה של הניסוי נשתמש בכדי למדידת ביצועים של פרוטוקול TCP בשם
sockperf. בצד השרת הפקודה המתאימה היא:

    sockperf server --tcp

בצד הלקוח הפעילו את sockperf למדידת קצב העברת הנתונים באמצעות בדיקת
throughput של sockperf. במצב זה התוכנית מנסה לשלוח את המספר המירבי של
בתים לצד השני עד לגודל חלון ה-TCP. הפעילו את הפקודה:

    sockperf throughput --tcp -i $server_ip --msg-size 1472 -t 5

אנו משתמשים בגודל הודעה מקסימלי (1472) על מנת לקבל קצב העברה גבוה יותר
ולהפחית היחס בין כמות העבודה הנדרשת מן המעבד למספר הבתים המועברים. ניתן
לשלוט במשך זמן הניסוי באמצעות הפרמטר
&lrm;`-t`.

במהלך הריצה, מדדו גם את ניצולת המעבד באמצעות הכלי `top` או הכלי הגרפי
System Monitor.
בכלי `top` תוכלו להציג את ניצול כל ליבה בנפרד באמצעות לחיצה על המקש <kbd>1</kbd>.
הכלי מציג (בשורה השלישית של הפלט) בנפרד את העומס בשל תוכניות משתמש (`us`)
ותוכניות משתמש בעדיפות נמוכה (`ni`),
ליבת מערכת ההפעלה (`sy`), המתנה לקלט/פלט (`wa`). אחוז הזמן של המעבד בו הוא ממתין ללא פעילות מופיע
תחת `id`.

### השהיית רשת

למדידת השהיית הרשת, נפעיל את `sockperf` במצב `ping-pong` בו כל הודעה נשלחת
רק לאחר קבלת ההודעה הקודמת (החליפו את הפרמטר `throughput` ב-`ping-pong`).
כך מדידת זמן ההעברה הכולל מאפשר למדוד את
השהיית הרשת בין שתי התחנות. השתמשו בפרוטוקול UDP המתאים יותר למדידת
השהייה על ידי השמטת הפרמטר
&lrm;`--tcp`
משורת הפקודה של `sockperf` (בצד השרת ובצד
הלקוח), ובחרו גודל הודעה מינימלי (14 בתים) כדי למדוד את השהיית הרשת ללא
זמן השידור.

### מעקף ליבה

עד עתה השתמשנו במימוש של פרוטוקול TCP בתוך ליבת מערכת ההפעלה. כעת נחליף
אותו על ידי שימוש בספריית VMA במימוש העוקף את ממשקי מערכת ההפעלה ומתקשר
ישירות עם כרטיס הרשת. כדי לגרום לתוכנית להשתמש ב-VMA נגדיר זמנית את
משתנה הסביבה `LD_PRELOAD=libvma.so`. כדי לקבל הרשאה לגישה ישירה לכרטיס
הרשת, עלינו לקבל הרשאה של משתמש-על באמצעות הפקודה sudo. לסיכום על מנת
להפעיל את sockperf נשתמש בפקודה:

    sudo env LD_PRELOAD=libvma.so sockperf …

השתמשו ב-VMA בצד השרת ובצד הלקוח. מדדו קצב ההעברה ואת השהיית הרשת תוך
שימוש בספריית VMA. מדדו גם את ניצולת המעבד. השוו את התוצאות והסבירו את
התוצאות שקיבלתם.

הערה: VMA עשוי להדפיס אזהרה על כך שאין דפים גדולים huge pages זמינים במכונה. ניתן להתעלם מאזהרה זו.

### האטת קצב המעבד

דרך אחרת לבחון את ניצולת המעבד היא באמצעות האטת תדר השעון שלו. בלינוקס
ניתן לבחור במנהלי תדר שעון שונים. נבחר בין מצבים powersave
ו-performance. במכונות הניסוי, תדר השעון כמעט נחלק לשניים במעבר למצב
powersave. כדי להחליף לכל הליבות את התדר השתמשו בפקודה:

    for core in $(seq 0 3) ; do sudo cpufreq-set -c $core -g $governor ; done

כאשר מחליפים את
&lrm;`$governor`
ב-`powersave` או `performance` לפי הצורך.

מדדו את קצב השליחה בתדר שעון נמוך ובתדר גבוה והשווה את התוצאות כאשר
משתמשים ב-VMA וכאשר משתמשים בליבת מערכת ההפעלה.

מדוע נרצה להשתמש בתדר שעון נמוך מהרגיל?

תרגיל 3: שימוש בפרוטוקול RoCE
-----------------------------

כעת נבחן את השימוש בפרוטוקול תקשורת מואץ בחומרה, כתחליף ל-TCP. נשתמש
באוסף ישומי perftest למדידת ביצועי RoCE.

למדידת קצב העברה נשתמש בכלי `ib_send_bw`. על השרת, נפעיל את הכלי ללא
פרמטרים נוספים:

    ib_send_bw

בצד הלקוח (השולח), נפעיל את הכלי עם כתובת השרת כפרמטר:

    ib_send_bw $server_ip

ניתן לשלוט במשך הניסוי באמצעות הפרמטר 
&lrm;`-D`.
יש להעביר את אותו משך הזמן גם
לשרת וגם ללקוח אחרת יתקבלו תוצאות שגויות. בנוסף, כלי perftest עשויים להדפיס אזהרה כאשר תדר השעון של המעבד אינו תואם לתדר המקסימלי שלו:

    Conflicting CPU frequency values detected: 3300.000000 != 1600.000000. CPU Frequency is not max.

ניתן להתעלם מאזהרה זו, או להוסיף את הדגל
&lrm;`-F`
כדי לבטל את האזהרה.

כעת הריצו את אותו הניסוי אבל תוך שימוש בגודל הודעה קטן (השתמשו בפרמטר
&lrm;`-s`)
של 4 בתים (העבירו את הפרמטר גם לשרת וגם ללקוח). מהו קצב ההעברה (מספר הודעות לשניה)
שהתקבל, ומדוע?

כדי למדוד את השהיית הרשת, נשתמש בכלי `ib_send_lat`, הפועל באופן דומה.

מדדו את קצב ההעברה והשהיית הרשת, והשוו את התוצאות לתוצאות שהתקבלו בשימוש
ב-VMA. מה מקור ההבדל?

### גישה לזכרון מרוחק

פרוטוקול RoCE מאפשר גם גישה לזכרון מרוחק ללא מעורבות של המעבד שאליו שייך
הזכרון. נדגים זאת באמצעות תוכנית הבדיקה `ib_write_bw`, בה תוכנית הלקוח
מבצעת כתיבות לזכרון של תוכנית השרת. אופן הפעולה שלה זהה לשאר תוכניות
perftest.

מדדו את קצב העברת הנתונים באמצעות `ib_write_bw` תוך שימוש בהודעות גדולות (גודל ברירת המחדל). מדדו במהלך הריצה את
ניצול המעבד בצד השרת ובצד הלקוח. הסבירו את ההבדלים בין הצדדים.

אופציונלי: כדי לוודא שהמעבד בצד השרת אינו מעורב, האטו את תדר השעון שלו,
ומדדו את קצב ההעברה שנית.

תרגיל 4: ריבוי ליבות
--------------------

כאשר צוואר הבקבוק בניסוי הוא העומס על המעבד הראשי, נוכל להשיג שיפור
ביצועים וקצב העברה גבוה יותר באמצעות ניצול מספר ליבות של המעבד. הזכרו בתוצאות
[lstopo](#lstopo)
ובמבנה המערכת שמצאתם באמצעותה.

בניסוי הבא נפעיל מספר תוכניות במקביל. ניתן לעשות זאת באמצעות פתיחה של
מספר לשוניות במסוף (צירוף המקשים 
&lrm;<kbd>Ctrl</kbd> + <kbd>Shift</kbd>+<kbd>T</kbd>)&lrm;.
תוכלו לפתוח מספר לשוניות גם עבור התחנה המרוחקת, ולהשתמש בכלי ssh כדי לפתוח מספר חיבורים מקבילים
לאותה תחנה.

הפעילו תהליך נפרד של `ib_send_bw` על כל אחת מהליבות בשרת (באמצעות
taskset). כדי למנוע התנגשויות בבחירת פורט הגישה לתהליכים השונים, השתמשו
בפרמטר
&lrm;`-p`
על מנת לבחור פורט שונה לכל תהליך. באופן דומה, הפעילו עותק נפרד
של לקוחות `ib_send_bw` כאשר כל לקוח פונה לשרת שונה. מדדו את סך קצב
ההעברה של כל הלקוחות, ואת ניצולת המעבדים הכוללת.

כעת חזרו על הניסוי אבל תוך שימוש בגודל הודעה קטן (השתמשו בפרמטר
&lrm;`-s`)
של 4 בתים. בדקו את הקצבים המתקבלים עם מספר ליבות בין 1 ל-4, וערכו תרשים
המשווה את קצב ההעברה בשני הגדלים. הסבירו את ההבדלים בתרשים בין גדלי
ההודעות השונים. מהו צוואר הבקבוק בכל ניסוי?

 <a name="חלק-ב"/> חלק שני - תכנות RDMA
====================

בחלק זה של הניסוי נתנסה בתכנות RDMA בשפת C באמצעות הספריה librdmacm. נשנה תוכנית דוגמה
המממשת מסד נתונים מפושט עם תקשורת דו-צדדית, ונלמד כיצד להחליף חלק מן הפעולות בפעולות
גישה לזכרון מרוחק על מנת לשפר את ביצועי המערכת.

המכונות שעליהן תבצעו את הניסוי הן משותפות, ולכן לפני תחילת העבודה צרו תיקיה תחת
תיקית הבית הכוללת את שמות הסטודנטים בשם התיקיה:

    cd ~
    mkdir $student_names
    cd $student_names

הורידו את קוד הדוגמה שממנו נתחיל באמצעות הפקודה:

    git clone https://github.com/haggaie/rdma-experiment.git

הפעולה תעתיק את הקבצים לתיקיה rdma-experiment/src. תוכנית הדוגמה היא שרת
מסד נתונים מפושט. מסד הנתונים מצמיד ערכים למפתחות, ומאפשר שליפה של ערך
בהינתן המפתח המתאים. הדוגמה מורכבת מתוכנית שרת `exp_server`, המקבלת
בקשות כתיבה וקריאה של נתונים ושומרת אותם במערך בזיכרון, ותוכנית לקוח
`exp_client` המאפשרת למשתמש לשמור ולקרוא מפתחות בצורה אינטראקטיבית.

על מנת לבנות את התוכנית, הפעילו את הסקריפט build.sh הנמצא בתיקיה
rdma-experiment/src. 
לאחר מכן התוכניות המוכנות צריכות להמצא בתיקיה
rdma-experiment/src/build. 
כדי להפעיל את התוכניות, הפעילו את תוכנית השרת
על מחשב השרת:

    exp_server [-p port_number]

ניתן לבחור מספר פורט שונה באמצעות הפרמטר
&lrm;`-p`,
למשל אם חולקים את השרת עם
מספר משתמשים.

את תוכנית הלקוח יש להפעיל עם כתובת ה-IP של השרת:

    exp_client -s $server_ip [-p port_number]

תוכנית הלקוח מבקשת קלט מהמשתמש בצורה מחזורית. בכל פעם יש לבחור את סוג
ההודעה – כתיבה למסד הנתונים, קריאה מתוכו, או סיום הריצה. אם המשתמש מבקש
לכתוב או לקרוא, התוכנית מבקשת את המפתח והערך המתאימים לפי הצורך, ומציגה
את הפלט המתקבל מהשרת בתגובה.

### ספרית rdmacm

התוכנית משתמשת בספריות rdmacm ו-ibverbs המשמשות לתכנות RDMA. היא כוללת
את האובייקטים הבאים:

  ----------------------------------      ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  מזהה חיבור `rdma_cm_id` (ID)&lrm;       מזהה את החיבור עם הצד השני ברשת, ומאפשר לבצע מולו פעולות של שליחה וקבלה.
                                     
                                          לכל ID יש תור שליחה הכולל הודעות לשליחה לצד השני (כולל פעולות גישה לזכרון מרוחק) ותור קבלה הכולל חוצצי זכרון המיועדים לקבלת הודעות.

  זכרון רשום memory region (MR)&lrm;      כדי לאפשר לכרטיס הרשת גישה ישירה לזכרון, יש לרשום את הזכרון המבוקש מראש. לאחר הרישום מתקבל אוביקט MR המייצג את הזכרון הרשום.

  השלמת משימה work completion (WC)&lrm;   לאחר ביצוע פעולת שליחה או קבלה בהצלחה, מתווספים נתוני השלמת משימה לתור פנימי המשוייך ל-ID. התוכנית יכולה לקרוא את הנתונים מהתור וכך לזהות שהפעולה הושלמה. רק לאחר השלמת הפעולה וקבלת הנתונים מותר לתוכנית לעשות שימוש בזכרון המשוייך לפעולה.
  ----------------------------------      ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### קריאה מרחוק

כדי להקל את העומס על השרת נשנה את פעולות הקריאה של מסד הנתונים. במקום
לשלוח הודעה לשרת בבקשה לקרוא ערך כלשהו, נשתמש בפעולת RDMA Read על מנת
לקרוא את הזכרון המרוחק ללא מעורבות של תוכנית השרת.

על מנת לשלוח פעולת קריאה, יש להשתמש בפונקציה `rdma_post_read`. פעולה זו
מקבלת כפרמטר את זהות החיבור אל השרת (id), כתובת ואורך של איזור בזכרון
המקומי אליו תועתק התשובה,

כדי לאפשר זאת, תוכנית השרת כבר רושמת את טבלת מסד הנתונים (המשתנה table
בקובץ `database.c`), ושולחת את פרטי ה-MR לתוכנית הלקוח. הפרטים שמורים
במשתנה `db_info` בקובץ
`rdma_client.c`.
על מנת שכרטיס הרשת יוכל לכתוב את תוצאת הקריאה הפעולה מקבלת גם כתובת יעד מקומית. גם כתובת זו צריכה להיות באיזור זכרון רשום (MR). תוכלו להשתמש למשל ב-MR הקיים `recv_mr` הכולל את המשתנה `recv_msg`.

ערכו את הפונקציה `rdma_read` ב-`rdma_client.c`, כך שתשלח בקשה לקריאת זכרון מרוחק של השרת. תוכלו להסתכל בפונקציות `rpc` ו-`transmit_message` על מנת לראות כיצד התוכנית שולחת הודעות לשרת ומקבלת תשובות.

### ניפוי שגיאות
על מנת לנפות שגיאות, ניתן להשתמש בתוכנית `gdb`. כדי לבנות גרסה מתאימה של התוכנית ניתן לערוך את `build.sh` ולהוסיף את הפרמטר
&lrm;`-DCMAKE_BUILD_TYPE=Debug`
לפקודה `cmake`.

קודי שגיאה המוחזרים מספרית `librdmacm` במשתנה `errno` הם קודים סטנדרטיים של POSIX. ניתן למצוא את רשימת ערכי השגיאה ב-[errno(3)&lrm;](http://man7.org/linux/man-pages/man3/errno.3.html).
ערכי השגיאה המתקבלים עם השלמת פעולת קבלה, שליחה או RDMA בשדה `ibv_wc.status` מופיעים ב[עמוד ההסבר לפונקציה `ibv_poll_cq`](http://www.rdmamojo.com/2013/02/15/ibv_poll_cq/) בבלוג RDMAmojo.

### מדידת ביצועים

שנו את תוכנית הלקוח כך שתבצע מספר רב של פעולות קריאה (100,000), ללא
אינטראקציה עם המשתמש (יש לבטל הדפסות בתוכנית באמצעות הפרמטר
&lrm;-q),
ומספר רב של פעולות עדכון. מדדו את הזמן שלוקח לבצע:

1. פעולות עדכון
2. פעולות קריאה (שליחה וקבלת הודעות באמצעות 
`rpc()`&lrm;)
3. פעולות קריאה (באמצעות RDMA)

השתמשו בפונקציה
[`clock_gettime`](https://linux.die.net/man/3/clock_gettime)
עם הפרמטר
`CLOCK_MONOTONIC`
כדי לקרוא את הזמן הנוכחי לפני ואחרי המדידה.

נספח א' - הכנה לניסוי
=====================

ניתן להשתמש במכונה וירטואלית כדי לדמות כרטיס רשת בעל יכולות RDMA. הורידו
את הגדרות המכונה באמצעות:

git clone <https://github.com/haggaie/rdma-experiment>

יש להתקין את [VirtualBox](https://www.virtualbox.org/wiki/Downloads) ואת
[Vagrant](https://www.vagrantup.com/downloads.html) (גרסה 2.0.3 ומעלה).

הפעילו את המכונות באמצעות vagrant up. בפעם הראשונה ההורדה וההתקנה עשויה
לקחת זמן.

כעת לרשותכם שתי מכונות וירטואליות בשמות client ו-server המחוברות ברשת
וירטואלית. תוכלו להתחבר לכל אחת מהן באמצעות vagrant ssh client או
vagrant ssh server.

בעת העבודה עם SoftRoCE (בעבודת ההכנה בבית) יש להפעיל את RoCE לאחר כל
הפעלה מחדש של המכונה באמצעות הפקודה:

    sudo rxe_cfg start

